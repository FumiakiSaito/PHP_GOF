# PHPデザインパターン

## オブジェクトの生成に関するパターン

### AbstractFactory
互いに関連したり依存しあうオブジェクト郡を、その具象クラスを明確にせずに生成するためのインタフェースを提供する

### Builder
複合オブジェクトについて、その作成過程を表現形式に依存しないものにすることにより  
同じ作成過程で異なる表現形式のオブジェクトを生成できるようにする

### FactoryMethod
オブジェクトを生成するときのインタフェースだけを既定して、実際にどのクラスをインスタンス化するかは  
サブクラスが決めるようにする。Factory Methodパターンはインスタンスかをサブクラスに任せる

### Prototype
生成すべきオブジェクトの種類を原型となるインスタンスを使って明確にし、それにコピーすることで新たなオブジェクトの生成を行う

### Singleton
あるクラスに対してインスタンスが1つしか存在しないことを保証し、それにアクセスするためのグローバルな方法を提供する

## プログラムの構造に関するパターン

### Adapter
あるクラスのインターフェースをクライアントが求めるほかのインターフェースへ変換する  
Adapterパターンは、インターフェースに互換性のないクラス同士を組み合わせることができるようにする  
あるメソッドを別メソッドでラップするイメージ。ラッパーパターンとも言われる  

### Bridge
抽出されたクラスと実装を分離して、それらを独立に変更できるようにする

### Composite
部分-全体階層を表現するために、オブジェクトを木構造に組み立てる  
Compositeパターンにより、クライアントは、個々のオブジェクトとオブジェクトを合成したものを一様に扱うことができるようになる  

### Decorator
オブジェクトに責任を動的に追加する  
Decoratorパターンはサブクラス化よりも柔軟な拡張方法を提供する  

### Facade
サブシステム内に存在する複数のインタフェースに1つの統一インタフェースを与える  
Facadoパターンはサブシステムの利用を容易にするための高レベルインタフェースを定義する

###Flyweight
多数の細かいオブジェクトを効率よくサポートするために共有を利用する

### Proxy
あるオブジェクトへのアクセスを制御するために、そのオブジェクトの代理または入れ物を提供する

## オブジェクトの振る舞いに関するパターン

### ChainOfResponsibility
1つ以上のオブジェクトに要求を処理する機会を与えることにより、  
要求を送信するオブジェクトと受信するオブジェクトの結合を避ける  
受信する複数のオブジェクトをチェーン状につなぎ、あるオブジェクトがその要求を処理するまで、そのチェーンに沿って要求を渡していく  

### Command
要求をオブジェクトとしてカプセル化することによって、様々な要求または要求からなるキューや  
ログによりクライアントをパラメータ化する。そして、取り消し可能な操作をサポートする

### Interpreter
言語に対して、文法表現と、それを使用して文を解釈するインタプリタを一緒に定義する

### Iterator
集約オブジェクトが基にある内部表現を公開せずにその要素に順にアクセスする方法を提供する

### Mediator
オブジェクト郡の相互作用をカプセル化するオブジェクトを定義する  
Mediatorパターンはオブジェクト同士がお互いを明示的に参照し合うことがないようにして結合度を低めることを促進する  
それにより、オブジェクトの相互作用を独立に変えることができるようになる

### Memento
カプセル化を破壊せずに、オブジェクトの内部状態をとらえて外面化しておき、オブジェクトを後にこの状態に戻すことができるようにする

### Observer
あるオブジェクトが状態を変えたときに、それに依存するすべてのオブジェクトに  
自動的にそのことが知らされ、また、それらが更新されるように、オブジェクト間に一対多の依存関係を定義する


## State
オブジェクトの内部状態が変化したときに、オブジェクトが振る舞いを変えるようにする  
クラス内では振る舞いの変化を記述せず、状態を表すオブジェクトを導入することでこれを実現する  

## Strategy
アルゴリズムの集合を定義し、各アルゴリズムをカプセル化して、それらを交換可能にする  
Strategyパターンを利用することで、アルゴリズムをそれを利用するクライアントからは独立に変更することができるようになる

## TemplateMethod
1つのオペレーションにアルゴリズムのスケルトンを定義しておき、  
その中のいくつかのステップについてはサブクラスでの定義に任せることにする  
TemplateMethod パターンでは、アルゴリズムの構造を変えずに

## Visitor
あるオブジェクト構造上の要素で実行されるオペレーションを実現する  
Visitorパターンによりオペレーションをくわえるオブジェクトのクラスに変更を加えずに  
新しいオペレーションを定義することができるようになる
アルゴリズム中のあるステップをサブクラスで定義する


